import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from growwapi import GrowwAPI
import numpy as np
from functools import lru_cache
import subprocess
import sys
import os
import plotly.graph_objects as go

# === Page setup ===
st.set_page_config(page_title="Trading Signal Predictor", layout="wide")
st.title("ğŸ“ˆ Trading Signal Predictor")

# === API Auth ===
st.sidebar.title("ğŸ” Groww API Auth")
api_key = st.sidebar.text_input("Enter your Groww API token", type="password")
if not api_key:
    st.warning("Please enter your Groww API token in the sidebar.")
    st.stop()

groww = GrowwAPI(api_key)

# === Load Instruments ===
@lru_cache(maxsize=1)
def load_instruments():
    df = pd.read_csv("instruments.csv", low_memory=False)
    groww.instruments = df
    groww._load_instruments = lambda: None
    groww._download_and_load_instruments = lambda: df
    groww.get_instrument_by_groww_symbol = lambda sym: df[df['groww_symbol'] == sym].iloc[0].to_dict()
    return df

try:
    instruments_df = load_instruments()
except Exception as e:
    st.error(f"âŒ instruments.csv load failed: {e}")
    st.stop()

# === Load ML Models ===
try:
    from strategy_1_model import buy_model, rr_model, compute_rsi
except Exception as e:
    st.error(f"âŒ Model import error: {e}")
    st.stop()

# === Show Guide Page ===
def show_guide():
    st.title("ğŸ“˜ Strategy Guide â€“ Signal Confidence Strength")
    st.markdown("""
    This section explains how to interpret the **confidence score** and resulting labels generated by the trading signal model.

    ### ğŸ” How Confidence Works:
    - The model outputs a probability that a candle is a **BUY signal**.
    - We translate this into **labels** for human-friendly interpretation.

    ### ğŸ§  Confidence Strength Breakdown

    | Confidence %       | Label              | Meaning                                  |
    |--------------------|--------------------|------------------------------------------|
    | **90â€“100%**        | ğŸ”¥ Strong BUY      | Very high conviction â€” ideal entry zone. |
    | **70â€“89.99%**      | âœ… Moderate BUY    | Good signal, with decent model backing.  |
    | **50â€“69.99%**      | âš ï¸ Weak BUY        | Slight positive bias â€” wait for confirmation. |
    | **30â€“49.99%**      | âš ï¸ Weak SELL       | Slight negative bias â€” stay cautious.    |
    | **10â€“29.99%**      | âŒ Moderate SELL   | Selling pressure likely â€” avoid buying.  |
    | **0â€“9.99%**        | ğŸ’€ Strong SELL     | Very bearish â€” exit or short if applicable. |

    ### ğŸ’¡ Tips:
    - Combine this with technical indicators (RSI, MACD) for better decisions.
    - Use **Strong BUY** or **Strong SELL** as clear entry/exit zones.
    - For **Weak signals**, observe next candles or add filters.
    """)

# === Sidebar Nav ===
page = st.sidebar.radio("ğŸ“š Navigation", ["ğŸ“ˆ Live Signal", "ğŸ§  Retrain Model", "ğŸ“˜ Strategy Guide"])
strategy_option = st.sidebar.selectbox("ğŸ§ª Strategy", ["Strategy 1"], index=0)

# === Time Setup ===
start_time_ist = datetime(2025, 6, 10, 9, 15, tzinfo=ZoneInfo("Asia/Kolkata"))
end_time_ist = datetime.now(ZoneInfo("Asia/Kolkata"))
now_ist = end_time_ist

if datetime.strptime("09:15", "%H:%M").time() <= now_ist.time() <= datetime.strptime("15:30", "%H:%M").time():
    st.markdown("<meta http-equiv='refresh' content='600'>", unsafe_allow_html=True)

# === Guide Page ===
if page == "ğŸ“˜ Strategy Guide":
    show_guide()
    st.stop()

# === Live Signal Page ===
if page == "ğŸ“ˆ Live Signal":
    def live_predict(symbol="NSE-NIFTY", interval_minutes=10):
        try:
            selected = groww.get_instrument_by_groww_symbol(symbol)
        except Exception as e:
            st.error(f"Instrument lookup error: {e}")
            return

        # Duration check to prevent API errors
        duration_minutes = (end_time_ist - start_time_ist).total_seconds() / 60
        safe_interval = max(interval_minutes, int(duration_minutes / 1400) + 1)

        try:
            data = groww.get_historical_candle_data(
                trading_symbol=selected['trading_symbol'],
                exchange=selected['exchange'],
                segment=selected['segment'],
                start_time=start_time_ist.strftime("%Y-%m-%d %H:%M:%S"),
                end_time=end_time_ist.strftime("%Y-%m-%d %H:%M:%S"),
                interval_in_minutes=safe_interval
            )
        except Exception as e:
            st.error(f"API error: {e}")
            return

        if not data or 'candles' not in data or len(data['candles']) == 0:
            st.error("No candle data available.")
            return

        df = pd.DataFrame(data['candles'], columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='s', utc=True).dt.tz_convert('Asia/Kolkata')
        df.sort_values('timestamp', inplace=True)
        df.reset_index(drop=True, inplace=True)

        # Indicators
        df['SMA_10'] = df['close'].rolling(10).mean()
        df['EMA_10'] = df['close'].ewm(span=10).mean()
        df['Momentum'] = df['close'] - df['close'].shift(10)
        df['Volatility'] = df['close'].rolling(10).std()
        df['RSI'] = compute_rsi(df['close'])

        latest = df[['SMA_10', 'EMA_10', 'RSI', 'Momentum', 'Volatility']].dropna().tail(1)
        if latest.empty:
            st.warning("Insufficient data for prediction.")
            return

        proba = buy_model.predict_proba(latest)[0]
        confidence = proba[1] * 100
        buy_signal = int(proba[1] > 0.5)
        rr_signal = rr_model.predict(latest)[0]

        # Label
        if confidence >= 90:
            label = "ğŸ”¥ Strong BUY"
            color = "green"
        elif confidence >= 70:
            label = "âœ… Moderate BUY"
            color = "green"
        elif confidence >= 50:
            label = "âš ï¸ Weak BUY"
            color = "orange"
        elif confidence >= 30:
            label = "âš ï¸ Weak SELL"
            color = "orange"
        elif confidence >= 10:
            label = "âŒ Moderate SELL"
            color = "red"
        else:
            label = "ğŸ’€ Strong SELL"
            color = "darkred"

        st.subheader("ğŸ“ˆ Signal Result")
        st.markdown(f"**Signal:** {'BUY' if buy_signal else 'HOLD / SELL'}")
        st.markdown(f"**Confidence:** <span style='color:{color}'>{confidence:.2f}% - {label}</span>", unsafe_allow_html=True)
        st.markdown(f"**Risk/Reward:** `{rr_signal:.4f}`")

        # Chart
        fig = go.Figure()
        fig.add_trace(go.Candlestick(x=df['timestamp'], open=df['open'], high=df['high'],
                                     low=df['low'], close=df['close'], name="Price"))
        fig.add_trace(go.Scatter(x=df['timestamp'], y=df['EMA_10'], name="EMA 10", line=dict(color="blue")))
        fig.add_trace(go.Scatter(x=df['timestamp'], y=df['SMA_10'], name="SMA 10", line=dict(color="orange")))
        st.plotly_chart(fig, use_container_width=True)

        # Raw Table
        st.dataframe(df.tail(10), use_container_width=True)

        # Export
        csv = df.to_csv(index=False).encode()
        st.download_button("ğŸ“¥ Download Data as CSV", data=csv, file_name="latest_candles.csv")

    # Sidebar trigger
    st.sidebar.markdown("### â–¶ Run Prediction")
    if st.sidebar.button("Run Live Prediction"):
        live_predict()

# === Retrain Page ===
if page == "ğŸ§  Retrain Model":
    st.title("ğŸ§  Retrain Trading Models")
    if st.button("ğŸ” Start Retraining"):
        st.info("ğŸ”„ Retraining startedâ€¦")
        try:
            process = subprocess.Popen(
                [sys.executable, "strategy_1_retrain.py"],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                universal_newlines=True
            )
            logs = ""
            output = st.empty()
            for line in process.stdout:
                logs += line
                output.code(logs)
            process.wait()
            if process.returncode == 0:
                st.success("âœ… Retraining complete!")
                st.rerun()
            else:
                st.error("âŒ Retraining failed.")
        except Exception as e:
            st.error(f"Error: {e}")
